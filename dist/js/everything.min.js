var gameLogic;!function(a){function b(a){for(var b=angular.copy(a),c=void 0,d=void 0,e=b.length;e;c=Math.floor(Math.random()*e),d=b[--e],b[e]=b[c],b[c]=d);return b}function c(b,c){if(0===b||0===c||b===a.ROWS-1||c===a.COLS-1)return!0;if(1===b||5===b){if(1===c||c>4)return!0}else if((2===b||4===b)&&c>4)return!0;return!1}function d(b){for(var c=[],d=0;d<a.ROWS;d++){c[d]=[];for(var e=0;e<a.COLS;e++)c[d][e]=0===d||0===e||d===a.ROWS-1||e===a.COLS-1}for(var f=[[1,0],[0,1],[-1,0],[0,-1]],g=1,h=1,i=0,j=0;!c[g][h];)c[g][h]=!0,b[g][h].label!==Resource.Water&&b[g][h].label!==Resource.Dust&&(b[g][h].rollNum=tokens[i++]),c[g+f[j][0]][h+f[j][1]]&&(j=(j+1)%f.length),g+=f[j][0],h+=f[j][1];return b}function e(a,b){for(var c=0;c<harborPos.length;c++)if(harborPos[c][0]===a&&harborPos[c][1]===b)return harbors[c];return null}function f(){for(var f=[],g=b(terrains),h=0,i=0;i<a.ROWS;i++){f[i]=[];for(var j=0;j<a.COLS;j++){var k=[-1,-1,-1,-1,-1,-1],l=[-1,-1,-1,-1,-1,-1],m=[-1,-1,-1,-1,-1,-1],n=c(i,j)?Resource.Water:g[h++],o={label:n,edges:k,vertices:l,vertexOwner:m,rollNum:-1,harbor:e(i,j),hasRobber:n===Resource.Dust};f[i][j]=o}}return d(f)}function g(a){for(var b=[],c=0;a>c;c++)b[c]=0;return b}function h(){for(var b=[],c=0;c<a.NUM_PLAYERS;c++)b[c]={id:c,points:0,resources:g(Resource.SIZE),devCards:g(DevCard.SIZE),knightsPlayed:0,longestRoad:0,construction:g(Construction.SIZE)};return b}function i(){for(var a={resources:g(Resource.SIZE),devCards:g(DevCard.SIZE)},b=0;b<Resource.SIZE;b++)a.resources[b]=19;for(var b=0;b<DevCard.SIZE;b++)switch(b){case DevCard.Knight:a.devCards[b]=14;break;case DevCard.Monopoly:a.devCards[b]=2;break;case DevCard.RoadBuilding:a.devCards[b]=2;break;case DevCard.YearOfPlenty:a.devCards[b]=2;break;case DevCard.VictoryPoint:a.devCards[b]=5}return a}function j(){return{longestRoad:{player:-1,length:4},largestArmy:{player:-1,num:2}}}function k(b){for(var c=-1,d=-1,e=0;e<a.ROWS;e++)for(var f=0;f<a.COLS;f++)if(b[e][f].hasRobber){c=e,d=f;break}return{row:c,col:d}}function l(){var a=f(),b=k(a);return{board:a,dices:[1,1],players:h(),bank:i(),awards:j(),robber:b,diceRolled:!1,devCardsPlayed:!1,delta:null,moveType:MoveType.INIT,eventIdx:-1,building:null}}function m(a,b,c){if(a.diceRolled)throw new Error("Dices already rolled")}function n(a,b,c){if(!canAffordConstruction(a,b))throw new Error("Insufficient resources to build "+b);if(!hasSufficientConstructsToBuild(a,b,c))throw new Error("Has no enough constructions to build "+b)}function o(a,b,c){n(a.players[c],Construction.Road,a.bank);var d=b.building,e=b.players[c];if(!canBuildRoadLegally(e,a.board,d.hexRow,d.hexCol,d.vertexOrEdge,d.init))throw new Error("Cannot build road legally!")}function p(a,b,c){n(a.players[c],Construction.Settlement,a.bank);var d=b.building,e=b.players[c];if(!canBuildSettlementLegally(e,a.board,d.hexRow,d.hexCol,d.vertexOrEdge,d.init))throw new Error("Cannot build settlement legally!")}function q(a,b,c){n(a.players[c],Construction.City,a.bank);var d=b.building,e=b.players[c];if(!canUpgradeSettlement(e,a.board,d.hexRow,d.hexCol,d.vertexOrEdge))throw new Error("Cannot build city legally!")}function r(a,b,c){if(!a.diceRolled)throw new Error("Need to roll dices first");v(b.players[c].resources)}function s(a,b,c){if(a.devCardsPlayed)throw new Error("Already played development cards");try{v(b.bank.resources)}catch(d){throw new Error("Bank Error: "+d.message)}}function t(a,b,c){for(var d=0,e=0,f=0;f<Resource.SIZE;f++)d+=a.players[c].resources[f],e+=b.players[c].resources[f];if(d>7&&e>d/2)throw new Error("Need to toss half of resource cards")}function u(a,b,c){if(angular.equals(a.robber,b.robber))throw new Error("Need to move robber")}function v(a){for(var b=0;b<Resource.SIZE;b++)if(a[b]<0)throw new Error("Insufficient resources: "+Resource[b])}function w(b,c,d){for(var e=0;e<a.ROWS;e++)for(var f=0;f<a.COLS;f++)if(null!==b[e][f].harbor&&b[e][f].harbor.trading===Resource.ANY&&b[e][f].harbor.trading===c)for(var g=b[e][f].harbor,h=0;6>h;h++)if(b[e][f].vertexOwner[h]===d&&(g.vertices[0]===h||g.vertices[1]===h))return b[e][f].harbor.trading===Resource.ANY?3:2;return 4}function x(a,b,c){if(!a.diceRolled)throw new Error("Need to roll dices first");var d={item:Resource.Dust,num:0},e={item:Resource.Dust,num:0};v(b.players[c].resources);for(var f=0;f<Resource.SIZE;f++){if(b.players[c].resources[f]<a.players[c].resources[f]){if(d.item!==Resource.Dust)throw new Error("Need to use same resources for trading");d={item:f,num:a.players[c].resources[f]-b.players[c].resources[f]}}if(b.players[c].resources[f]>a.players[c].resources[f]){if(e.item!==Resource.Dust)throw new Error("One resource per trade");e={item:f,num:b.players[c].resources[f]-a.players[c].resources[f]}}}if(d.item===e.item)throw new Error("Cannot trade the same resources");if(e.num*w(b.board,e.item,c)!==d.num)throw new Error("Wrong trading ratio")}function y(a){var b=a.stateBeforeMove,c=a.move.stateAfterMove,d=c.moveType===MoveType.ROBBER_EVENT?b.eventIdx:a.turnIndexBeforeMove;a.move.turnIndexAfterMove,a.move.stateAfterMove.delta;if(c.moveType!==MoveType.INIT&&c.moveType!==MoveType.WIN){if(c.moveType>=MoveType.SIZE||null===L[c.moveType])throw new Error("Unknown move!");L[c.moveType](b,c,d)}}function z(b){for(var c=[],d=0;d<a.NUM_PLAYERS;d++)c[d]=0;for(var d=0;d<a.NUM_PLAYERS;d++){for(var e=b.players[d],f=0;f<Construction.SIZE;f++)switch(f){case Construction.Settlement:c[d]+=1*e.construction[Construction.Settlement];break;case Construction.City:c[d]+=2*e.construction[Construction.City]}c[d]+=e.devCards[DevCard.VictoryPoint]}return-1!==b.awards.longestRoad.player&&(c[b.awards.longestRoad.player]+=2),-1!==b.awards.largestArmy.player&&(c[b.awards.largestArmy.player]+=2),c}function A(a,b){if(a.currState.diceRolled)throw new Error("Dices already rolled!");return null}function B(a,b){return null}function C(a,b){return null}function D(a,b){var c=angular.copy(a.currState);if(c.delta=null,c.devCardsPlayed)throw new Error("Already played development card!");if(c.players[a.playerIdx].devCards[DevCard.Knight]<=0)throw new Error("Doesn't have knight card on hand!");var d=angular.copy(c);return d.devCardsPlayed=!0,d.moveType=MoveType.KNIGHT,d.eventIdx=-1,d.building=null,d.players[a.playerIdx].knightsPlayed+=1,d.players[a.playerIdx].devCards[DevCard.Knight]-=1,d.players[a.playerIdx].knightsPlayed>c.awards.largestArmy.num&&(d.awards.largestArmy={player:a.playerIdx,num:d.players[a.playerIdx].knightsPlayed}),{endMatchScores:z(d),turnIndexAfterMove:b,stateAfterMove:d}}function E(a,b){return null}function F(a,b){return null}function G(a,b){return null}function H(a,b){return null}function I(a,b){return null}function J(a,b){return null}function K(b,c){var d=angular.copy(b.currState);d.delta=null;for(var e=z(d),f=!1,g=0;g<a.NUM_PLAYERS;g++)if(e[g]>=10){f=!0;break}var h=angular.copy(d);return h.diceRolled=!1,h.devCardsPlayed=!1,h.moveType=f?MoveType.WIN:MoveType.INIT,h.eventIdx=-1,h.building=null,h.delta=d,{endMatchScores:e,turnIndexAfterMove:(c+1)%a.NUM_PLAYERS,stateAfterMove:h}}a.ROWS=7,a.COLS=7,a.NUM_PLAYERS=4,a.getInitialState=l;var L=[null,m,o,p,q,r,s,s,s,null,t,u,null,x];a.checkMoveOk=y,a.onRollDice=A,a.onInitBuilding=B,a.onBuilding=C,a.onKnight=D,a.onMonopoly=E,a.onYearOfPlenty=F,a.onRobberEvent=G,a.onRobberMove=H,a.onRobPlayer=I,a.onTradingWithBank=J,a.onEndTurn=K}(gameLogic||(gameLogic={}));var game;!function(a){function b(){}function c(a,b){}function d(a,b){return!0}function e(a,b){return!0}function f(a,b){return!0}function g(a,b){return!1}function h(a){return!0}a.animationEnded=!1,a.canMakeMove=!1,a.isComputerTurn=!1,a.move=null,a.state=null,a.isHelpModalShown=!1,a.init=b,a.cellClicked=c,a.shouldShowImage=d,a.isPieceX=e,a.isPieceO=f,a.shouldSlowlyAppear=g,a.clickedOnModal=h}(game||(game={})),angular.module("myApp",["ngTouch","ui.bootstrap","gameServices"]).run(function(){$rootScope.game=game,game.init()});var aiService;!function(a){function b(a){return d(a,{millisecondsLimit:1e3})}function c(a,b){for(var c=[],d=0;d<gameLogic.ROWS;d++)for(var e=0;e<gameLogic.COLS;e++)try{}catch(f){}return c}function d(a,b){return alphaBetaService.alphaBetaDecision(a,a.turnIndexAfterMove,f,e,null,b)}function e(a,b){var c=a.endMatchScores;return c?c[0]>c[1]?Number.POSITIVE_INFINITY:c[0]<c[1]?Number.NEGATIVE_INFINITY:0:0}function f(a,b){return c(a.stateAfterMove,b)}a.findComputerMove=b,a.getPossibleMoves=c,a.createComputerMove=d}(aiService||(aiService={}));
//# sourceMappingURL=everything.min.js.map